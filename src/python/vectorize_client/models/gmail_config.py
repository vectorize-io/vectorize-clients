# coding: utf-8

"""
    Vectorize API

    API for Vectorize services (Beta)

    The version of the OpenAPI document: 0.1.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class GMAILConfig(BaseModel):
    """
    Configuration for Gmail connector
    """ # noqa: E501
    from_filter_type: StrictStr = Field(alias="from-filter-type")
    to_filter_type: StrictStr = Field(alias="to-filter-type")
    cc_filter_type: StrictStr = Field(alias="cc-filter-type")
    subject_filter_type: StrictStr = Field(alias="subject-filter-type")
    label_filter_type: StrictStr = Field(alias="label-filter-type")
    var_from: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="From Address Filter. Only include emails from these senders. Example: Add sender email(s)", alias="from")
    to: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="To Address Filter. Only include emails sent to these recipients. Example: Add recipient email(s)")
    cc: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="CC Address Filter. Only include emails with these addresses in CC field. Example: Add CC email(s)")
    include_attachments: Optional[StrictBool] = Field(default=False, description="Include Attachments. Include email attachments in the processed content", alias="include-attachments")
    subject: Optional[StrictStr] = Field(default=None, description="Subject Filter. Include emails with these keywords in the subject line. Example: Add subject keywords")
    start_date: Optional[date] = Field(default=None, description="Start Date. Only include emails sent after this date (exclusive). Format: YYYY-MM-DD.. Example: e.g., 2024-01-01", alias="start-date")
    end_date: Optional[date] = Field(default=None, description="End Date. Only include emails sent before this date (exclusive). Format: YYYY-MM-DD.. Example: e.g., 2024-01-31", alias="end-date")
    max_results: Optional[Union[StrictFloat, StrictInt]] = Field(default=-1, description="Maximum Results. Enter -1 for all available emails, or specify a limit. . Example: Enter maximum number of threads to retrieve", alias="max-results")
    messages_to_fetch: Optional[List[StrictStr]] = Field(default=None, description="Messages to Fetch. Select which categories of messages to include in the import.", alias="messages-to-fetch")
    label_ids: Optional[StrictStr] = Field(default=None, description="Label Filters. Include emails with these labels. Example: e.g., INBOX, IMPORTANT, CATEGORY_SOCIAL", alias="label-ids")
    __properties: ClassVar[List[str]] = ["from-filter-type", "to-filter-type", "cc-filter-type", "subject-filter-type", "label-filter-type", "from", "to", "cc", "include-attachments", "subject", "start-date", "end-date", "max-results", "messages-to-fetch", "label-ids"]

    @field_validator('var_from')
    def var_from_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[^\s@]+@[^\s@]+\.[^\s@]+$", value):
            raise ValueError(r"must validate the regular expression /^[^\s@]+@[^\s@]+\.[^\s@]+$/")
        return value

    @field_validator('to')
    def to_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[^\s@]+@[^\s@]+\.[^\s@]+$", value):
            raise ValueError(r"must validate the regular expression /^[^\s@]+@[^\s@]+\.[^\s@]+$/")
        return value

    @field_validator('cc')
    def cc_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[^\s@]+@[^\s@]+\.[^\s@]+$", value):
            raise ValueError(r"must validate the regular expression /^[^\s@]+@[^\s@]+\.[^\s@]+$/")
        return value

    @field_validator('messages_to_fetch')
    def messages_to_fetch_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['all', 'inbox', 'sent', 'archive', 'spam-trash', 'unread', 'starred', 'important']):
                raise ValueError("each list item must be one of ('all', 'inbox', 'sent', 'archive', 'spam-trash', 'unread', 'starred', 'important')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GMAILConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GMAILConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "from-filter-type": obj.get("from-filter-type") if obj.get("from-filter-type") is not None else 'OR',
            "to-filter-type": obj.get("to-filter-type") if obj.get("to-filter-type") is not None else 'OR',
            "cc-filter-type": obj.get("cc-filter-type") if obj.get("cc-filter-type") is not None else 'OR',
            "subject-filter-type": obj.get("subject-filter-type") if obj.get("subject-filter-type") is not None else 'AND',
            "label-filter-type": obj.get("label-filter-type") if obj.get("label-filter-type") is not None else 'AND',
            "from": obj.get("from"),
            "to": obj.get("to"),
            "cc": obj.get("cc"),
            "include-attachments": obj.get("include-attachments") if obj.get("include-attachments") is not None else False,
            "subject": obj.get("subject"),
            "start-date": obj.get("start-date"),
            "end-date": obj.get("end-date"),
            "max-results": obj.get("max-results") if obj.get("max-results") is not None else -1,
            "messages-to-fetch": obj.get("messages-to-fetch"),
            "label-ids": obj.get("label-ids")
        })
        return _obj


